
/*
 * Invoked when a new voice command is given.
 *
 * Looks up [_arg] command from database, and if existing, evaluates it.
 * If the command does not exist, it will ask user if he wants to create 
  * a new command.
 */
create-event:hyperlang.command.handle

  /*
   * Checking if anything was given, and if not, closing Hyperlang.
   */
  if:x:/../*/_arg?value
    =:
    or:x:/../*/_arg?value
      not

    /*
     * Stopping Hyperlang, and returning early to avoid evaluating the rest 
     * of our event.
     */
    hyperlang.listen:[Waiting]
    return

  /*
   * Retrieving language for current user, which is necessary to filter our results.
   */
  hyperlang.settings.get-language

  /*
   * Looks up command from database.
   *
   * But first we must check to see if we have a current "position" in our
   * grammar graph, which will restrict the commands accordingly.
   */
  .command
  p5.mysql.connect:[hyperlang]
    hyperlang.grammar-position.get
    whoami
    if:x:/@hyperlang.grammar-position.get?value

      /*
       * Current position exists, retrieving command having current position 
       * as its parent, and global commands.
       *
       * Notice, we sort by "global", and we only select the first match, meaning 
       * that commands that are not global will be prioritized.
       */
      p5.mysql.select:@"select c.id, c.parent, c.hyperlambda, p.command, p.id as phraseid from commands c inner join phrases p on p.commandid = c.id 
where (soundex(p.command) = soundex(@command) or p.command = @command or p.command like @command2) and (c.parent = @parent or c.global = 1) and (c.username is null or c.username = @username) and (lang = @lang or lang = @sublang)
order by `global` limit 1"
        @command:x:/../*/_arg?value
        @command2:%{0}%
          :x:/../*/_arg?value
        @parent:x:/@hyperlang.grammar-position.get?value
        @username:x:/@whoami/*/username?value
        @lang:x:/@hyperlang.settings.get-language/*/lang?value
        @sublang:x:/@hyperlang.settings.get-language/*/sublang?value

      /*
       * Adding command to buffer above.
       */
      add:x:/@.command
        src:x:/@p5.mysql.select/*/*

    else

      /*
       * No current position, retrieving command having "null" parent, and global commands.
       *
       * Notice, we sort by "global", and we only select the first match, meaning 
       * that commands that are not global will be prioritized.
       */
      p5.mysql.select:@"select c.id, c.parent, c.hyperlambda, p.command, p.id as phraseid from commands c inner join phrases p on p.commandid = c.id 
where (soundex(p.command) = soundex(@command) or p.command = @command or p.command like @command2) and c.parent is null and (c.username is null or c.username = @username) and (lang = @lang or lang = @sublang)
order by `global` limit 1"
        @command:x:/../*/_arg?value
        @command2:%{0}%
          :x:/../*/_arg?value
        @username:x:/@whoami/*/username?value
        @lang:x:/@hyperlang.settings.get-language/*/lang?value
        @sublang:x:/@hyperlang.settings.get-language/*/sublang?value

      /*
       * Adding command to buffer above.
       */
      add:x:/@.command
        src:x:/@p5.mysql.select/*/*

    /*
     * Make sure we show the user what we heard, before we invoke lambda,
     * such that lambda can override text to show if it wants to.
     */
    hyperlang.set-text:x:/../*/_arg?value

    /*
     * Checking to see if we actually found a command.
     */
    if:x:/@.command/*

      /*
       * Success, we have a command in the current position, matching our 
       * specified [_arg].
       */
      hyper2lambda:x:/@.command/*/hyperlambda?value

      /*
       * Making sure we wrap evaluation in a try/catch block, and that we pass
       * in the command's id.
       */
      try
        eval-x:x:/+/*
        eval:x:/@hyper2lambda
          id:x:/@.command/*/id?value
          phraseid:x:/@.command/*/phraseid?value
        if:x:/@eval?value
          !=:bool:false

          /*
           * Notice, if lambda returns "false", we do not push the id of the current
           * command unto our stack.
           */
          hyperlang.grammar-position.push:x:/@.command/*/id?value

      catch

        /*
         * Giving feedback to user.
         */
        hyperlang.listen:An exception occurred
        micro.windows.info:x:/..catch/*/message?value
          class:micro-windows-info warning

      /*
       * Updating "lastused" for phrase.
       *
       * This is done, since we always "prioritize" the last used phrase, when
       * suggesting phrases, and selecting from our phrases table. Such that the
       * most commonly used phrases will always appear first.
       */
      p5.types.date.now
      p5.mysql.update:@"update phrases set lastused = @lastused where id = @id"
        @lastused:x:/@p5.types.date.now?value
        @id:x:/@.command/*/phraseid?value

    else

      /*
       * The specified [_arg] command doesn't exist, asking user if he wants to
       * create a new association for the given [_arg] command, or if he wants to
       * discard input, and rephrase his command.
       *
       * Waiting for user to say tell us what to do.
       *
       * Giving a visual clue to user, to inform him that he can say "teach"
       * to teach the computer a new word.
       *
       * Notice, the user is only allowed to configure new words, if he is root.
       * If not, we simply say "I don't understand".
       */
      whoami
      if:x:/@whoami/*/role?value
        !=:root

        /*
         * Computer didn't understand phrase, and user is not root.
         * Informing user and returning early.
         */
        hyperlang.listen:[I don't understand]
        return

      hyperlang.language.get-localized-phrase:[Say 'teach' to teach the computer]
      hyperlang.set-text:{0} '{1}'
        :x:/@hyperlang.language.get-localized-phrase?value
        :x:/../*/_arg?value
      eval-x:x:/+/*/*/*/*/hyperlang.command.create
      hyperlang.listen:[I don't understand]
        onfinish


          /*
           * Checking if user said "I will teach you".
           */
          hyperlang.language.get-localized-phrase:[Teach]
          set:x:/./*/switch/*/case/=teach?value
            src:x:/@hyperlang.language.get-localized-phrase?value
          switch:x:/../*/text?value
            case:teach

              /*
               * Invoking Active Event responsible for creating a "phrase2hyper"
               * association, making sure we pass in what was actually spoken,
               * and the current "grammar position" if any.
               */
              hyperlang.grammar-position.get
              if:x:/@hyperlang.grammar-position.get?value
                eval-x:x:/+/*/*
                add:x:/..case/*/hyperlang.command.create
                  src
                    pos:x:/@hyperlang.grammar-position.get?value
              hyperlang.command.create:x:/../*/_arg?value

            default

              /*
               * Unless the user says "yes" or "no", we assume it's the actual
               * command he wanted to utter.
               */
              hyperlang.command.handle:x:/../*/text?value
