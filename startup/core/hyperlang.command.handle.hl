
/*
 * Invoked when a new voice command is given.
 *
 * Looks up [_arg] or [id] command from database, and if existing, evaluates it.
 * [id] is expected to be a "phrase ID" from database.
 *
 * Either supply [_arg] or [id], and not both.
 *
 * If the command does not exist, it will ask user if he wants to create 
 * a new command.
 */
create-event:hyperlang.command.handle

  /*
   * Sanity checking arguments.
   */
  micro.lambda.contract.optional:x:/..
    id:long
    _arg:string

  /*
   * Sanity check.
   */
  if:x:/../*/_arg
    and:x:/../*/id
    throw:Supply either [_arg] or [id], and not both.

  /*
   * Checking if anything was given, and if not, restarting listening loop.
   */
  if:x:/../*/_arg?value
    =:
    or:x:/../*/_arg?value
      not
    and:x:/../*/id?value
      not

    /*
     * Stopping Hyperlang, and returning early to avoid evaluating the rest 
     * of our event.
     */
    hyperlang.set-text:[Waiting]
    hyperlang.listen
    return

  /*
   * Necessary to parametrise SQL.
   */
  whoami
  hyperlang.settings.get-language
  hyperlang.grammar-position.get

  /*
   * Dynamically building our SQL, depending upon whethere or not we should look
   * at "root" level, use the given [id], or search using text.
   */
  _sql:@"select p.command, c.id, c.hyperlambda, p.id as phraseid from commands c 
  inner join phrases p on p.commandid = c.id 
  where (c.username is null or c.username = @username) and (lang = @lang or lang = @sublang)"

  /*
   * Checking type of invocation.
   */
  if:x:/../*/_arg?value

    /*
     * Make sure we show the user what we heard.
     *
     * Notice, since this is done before we invoke lambda for command, this allows
     * the lambda to override what's displayed to user.
     */
    hyperlang.set-text:x:/../*/_arg?value

    /*
     * Text based search
     */
    set:x:/@_sql?value
      src:@"{0} and soundex(p.command) = soundex(@command)"
        :x:/@_sql?value
    add:x:/../*/p5.mysql.connect/*/p5.mysql.select
      src
        @command:x:/../*/_arg?value

  else

    /*
     * Looking for a specified [id] phrase.
     */
    set:x:/@_sql?value
      src:@"{0} and p.id = @id"
        :x:/@_sql?value
    add:x:/../*/p5.mysql.connect/*/p5.mysql.select
      src
        @id:x:/../*/id?value.long

  /*
   * Checking if we have a current level.
   */
  if:x:/@hyperlang.grammar-position.get?value

    /*
     * Adding parent criteria.
     */
    set:x:/@_sql?value
      src:@"{0} and (parent = @parent or global = 1)"
        :x:/@_sql?value
    add:x:/../*/p5.mysql.connect/*/p5.mysql.select
      src
        @parent:x:/@hyperlang.grammar-position.get?value

  else

    /*
     * Only looking for empty parents, and global commands.
     */
    set:x:/@_sql?value
      src:@"{0} and (parent is null or global = 1)"
        :x:/@_sql?value

  /*
   * Looks up command from database.
   */
  p5.mysql.connect:[hyperlang]

    /*
     * Evaluating paramtrised SQL now.
     */
    p5.mysql.select:"{0} order by parent desc, global limit 1"
      :x:/@_sql?value
      @username:x:/@whoami/*/username?value
      @lang:x:/@hyperlang.settings.get-language/*/lang?value
      @sublang:x:/@hyperlang.settings.get-language/*/sublang?value

    /*
     * Checking to see if we actually found a command.
     */
    if:x:/@p5.mysql.select/*

      /*
       * Checking type of invocation, and if it's based upon ID search, we display
       * the command name from our SQL query.
       */
      if:x:/../*/_arg?value
        not

        /*
         * Make sure we show the user the command we're executing.
         */
        hyperlang.set-text:x:/@p5.mysql.select/*/*/command?value

      /*
       * Success, we have a command in the current position, matching our 
       * specified [_arg].
       */
      hyper2lambda:x:/@p5.mysql.select/*/*/hyperlambda?value

      /*
       * Evaluating the command.
       */
      eval-x:x:/+/*
      eval:x:/@hyper2lambda
        id:x:/@p5.mysql.select/*/*/id?value
        phraseid:x:/@p5.mysql.select/*/*/phraseid?value
        spoken:x:/../*/_arg?value
        matches:x:/@p5.mysql.select/*/*/command?value
      if:x:/@eval?value
        !=:bool:false

        /*
         * Notice, if lambda returns "false", we do not push the ID of the current
         * command unto our stack.
         */
        hyperlang.grammar-position.push:x:/@p5.mysql.select/*/*/id?value

      /*
       * Updating "lastused" for phrase.
       *
       * This is done, since we always "prioritize" the last used phrase, when
       * suggesting phrases, and selecting from our phrases table. Such that the
       * most commonly used phrases will always appear first.
       */
      p5.types.date.now
      p5.mysql.update:@"update phrases set lastused = @lastused where id = @id"
        @lastused:x:/@p5.types.date.now?value
        @id:x:/@p5.mysql.select/*/*/phraseid?value

    else

      /*
       * The specified [_arg] command doesn't exist, asking user if he wants to
       * create a new association for the given [_arg] command, or if he wants to
       * discard input, and rephrase his command.
       *
       * Waiting for user to say tell us what to do.
       *
       * Giving a visual clue to user, to inform him that he can say "teach"
       * to teach the computer a new word.
       *
       * Notice, the user is only allowed to configure new words, if he is root.
       * If not, we simply say "I don't understand".
       */
      whoami
      if:x:/@whoami/*/role?value
        !=:root

        /*
         * Computer didn't understand phrase, and user is not root.
         *
         * Informing user and returning early.
         */
        hyperlang.listen:[I don't understand]
        return

      /*
       * User is "root", allowing him the option to teach a new command.
       *
       * First updating text widget of that user has the option to teach a new command.
       */
      hyperlang.language.get-localized-phrase:[Say 'teach' to teach the computer]
      hyperlang.set-text:{0} '{1}'
        :x:/@hyperlang.language.get-localized-phrase?value
        :x:/../*/_arg?value

      /*
       * Making sure we display "add command" button.
       */
      hyperlang.display-create-command-button:x:/../*/_arg?value

      /*
       * Then asking the user if he wants to teach the computer or not.
       *
       * If user answers anything but what is found in [Teach] (localized phrase),
       * we assume it's another command, and "recursively" invoke "self".
       */
      eval-x:x:/+/*/*/*/*/hyperlang.command.create
      hyperlang.listen:[I don't understand]
        onfinish

          /*
           * Checking if user said "I will teach you".
           */
          hyperlang.language.get-localized-phrase:[Teach]
          set:x:/../*/switch/*/case/=teach?value
            src:x:/@hyperlang.language.get-localized-phrase?value
          switch:x:/../*/text?value
            case:teach

              /*
               * Deletes the visual clue, indicating we're listening for input.
               */
              micro.css.delete:hyperlang-listener
                class:hyperlang-listening

              /*
               * Invoking Active Event responsible for creating a "phrase2hyper"
               * association, making sure we pass in what was actually spoken,
               * and the current "grammar position" if any.
               */
              hyperlang.grammar-position.get
              if:x:/@hyperlang.grammar-position.get?value
                eval-x:x:/+/*/*
                add:x:/..case/*/hyperlang.command.create
                  src
                    pos:x:/@hyperlang.grammar-position.get?value
              hyperlang.command.create:x:/../*/_arg?value

            default

              /*
               * Hiding our "create command button".
               */
              hyperlang.hide-create-command-button

              /*
               * Unless the user says "yes" or "no", we assume the engine recognised
               * erronously, and that what he spoke now, was what he actually wants to
               * do, for simplicity reasons.
               *
               * This allows for saving one roundtrip to speech recognition engine, asking
               * user to not wanting to create a new command.
               */
              hyperlang.command.handle:x:/../*/text?value
