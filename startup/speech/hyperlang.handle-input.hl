
/*
 * Invoked when a new voice command is given.
 *
 * Looks up [_arg] command from database, and if existing, evaluates it - Otherwise,
 * will ask user if he wants to create a mapping.
 */
create-event:hyperlang.handle-input

  /*
   * Checking if anything was given, and if not, closing Hyperlang.
   */
  if:x:/../*/_arg?value
    =:
    or:x:/../*/_arg?value
      not

    /*
     * Stopping Hyperlang, and returning early to avoid evaluating the rest 
     * of our event.
     */
    hyperlang.quit
    return

  /*
   * Figuring out language for current user, which is necessary to filter our results.
   */
  .defaults
    voice:Karen,en-AU
  p5.auth.my-settings.get
  split:x:(/@p5.auth.my-settings.get/*/hyperlang/*/voice|/@.defaults/*/voice)/$?value
    =:,
  split:x:/@split/0/-?name
    =:-

  /*
   * Looks up command from database.
   *
   * But first we must check to see if we have a current "position" in our
   * grammar graph, which will restrict the commands accordingly.
   */
  .command
  p5.mysql.connect:[hyperlang]
    hyperlang.position.get
    whoami
    if:x:/@hyperlang.position.get?value

      /*
       * Current position exists, retrieving command having current position 
       * as its parent, and global commands.
       *
       * Notice, we sort by "global", and we only select the first match, meaning 
       * that commands that are not global will be prioritized.
       */
      p5.mysql.select:@"select c.id, c.parent, c.hyperlambda, p.command from commands c inner join phrases p on p.commandid = c.id 
where p.command = @command and (c.parent = @parent or c.global = 1) and (c.username is null or c.username = @username) and (lang = @lang or lang = @mainlang)
order by `global` limit 1"
        @command:x:/../*/_arg?value
        @parent:x:/@hyperlang.position.get?value
        @username:x:/@whoami/*/username?value
        @lang:x:/@split/@split/0/-?name
        @mainlang:x:/@split/0?name

      /*
       * Adding command to buffer above.
       */
      add:x:/@.command
        src:x:/@p5.mysql.select/*/*

    else

      /*
       * No current position, retrieving command having "null" parent, and global commands.
       *
       * Notice, we sort by "global", and we only select the first match, meaning 
       * that commands that are not global will be prioritized.
       */
      p5.mysql.select:@"select c.id, c.parent, c.hyperlambda, p.command from commands c inner join phrases p on p.commandid = c.id 
where p.command = @command and c.parent is null and (c.username is null or c.username = @username) and (lang = @lang or lang = @mainlang)
order by `global` limit 1"
        @command:x:/../*/_arg?value
        @username:x:/@whoami/*/username?value
        @lang:x:/@split/@split/0/-?name
        @mainlang:x:/@split/0?name

      /*
       * Adding command to buffer above.
       */
      add:x:/@.command
        src:x:/@p5.mysql.select/*/*

    /*
     * Make sure we show the user what we heard.
     */
    hyperlang.set-text:x:/../*/_arg?value

    /*
     * Making sure we set the position before we invoke the Hyperlambda, such that
     * any lambda object can explicitly reset the position, if they want to.
     *
     * Notice, we only update position if we found a command for phrase.
     */
    if:x:/@.command/*
      hyperlang.position.set:x:/@.command/*/id?value

    /*
     * Checking to see if we actually found a command.
     */
    if:x:/@.command/*

      /*
       * Success, we have a command in the current position, matching our 
       * specified [_arg].
       */
      hyper2lambda:x:/@.command/*/hyperlambda?value
      eval:x:/@hyper2lambda

    else

      /*
       * The specified [_arg] command doesn't exist, asking user if he wants to
       * create a new association for the given [_arg] command, or if he wants to
       * discard input, and rephrase his command.
       *
       * Waiting for user to say tell us what to do.
       *
       * Giving a visual clue to user, to inform him that he can say "teach"
       * to teach the computer a new word.
       *
       * Notice, the user is only allowed to configure new words, if he is root.
       * If not, we simply say "I don't understand".
       */
      whoami
      if:x:/@whoami/*/role?value
        !=:root

        /*
         * Computer didn't understand phrase, and user is not root.
         * Informing user and returning early.
         */
        hyperlang.listen:[I don't understand]
        return

      hyperlang.get-localized-phrase:[Say 'teach' to teach the computer]
      hyperlang.set-text:{0} '{1}'
        :x:/@hyperlang.get-localized-phrase?value
        :x:/../*/_arg?value
      eval-x:x:/+/*/*/*/*/hyperlang.create-phrase2hyper-association
      hyperlang.listen:[I don't understand]
        onfinish


          /*
           * Checking if user said "teach".
           */
          hyperlang.get-localized-phrase:[Teach]
          set:x:/./*/switch/0?value
            src:x:/@hyperlang.get-localized-phrase?value
          switch:x:/../*/text?value
            case:teach

              /*
               * Invoking Active Event responsible for creating a "phrase2hyper"
               * association, making sure we first retrieve what was spoken.
               */
              hyperlang.create-phrase2hyper-association:x:/../*/_arg?value

            default

              /*
               * Unless the user says "yes" or "no", we assume it's the actual
               * command he wanted to utter.
               */
              hyperlang.handle-input:x:/../*/text?value
