
/*
 * Invoked when a new voice command is given.
 *
 * Looks up [_arg] command from database, and if existing, evaluates it - Otherwise,
 * will ask user if he wants to create a mapping.
 */
create-event:hyperlang.handle-input

  /*
   * Checking if anything was given, and if not, closing Hyperlang.
   */
  if:x:/../*/_arg?value
    =:
    or:x:/../*/_arg?value
      not

    /*
     * Stopping Hyperlang, and returning early to avoid evaluating the rest 
     * of our event.
     */
    hyperlang.quit
    return

  /*
   * Looks up command from database.
   *
   * But first we must check to see if we have a current "position" in our
   * grammar graph, which will restrict the commands accordingly.
   */
  .command
  p5.mysql.connect:[hyperlang]
    hyperlang.get-position
    whoami
    if:x:/@hyperlang.get-position?value

      /*
       * Current position exists, retrieving command having current position 
       * as its parent.
       */
      p5.mysql.select:@"select c.id, c.parent, c.hyperlambda, p.command from commands c inner join phrases p on p.commandid = c.id 
where p.command = @command and (c.parent = @parent or c.global = 1) and (c.username is null or c.username = @username)
order by `global`"
        @command:x:/../*/_arg?value
        @parent:x:/@hyperlang.get-position?value
        @username:x:/@whoami/*/username?value

      /*
       * Adding command to buffer above.
       */
      add:x:/@.command
        src:x:/@p5.mysql.select/*/*

    else

      /*
       * No current position, retrieving command having "null" parent.
       */
      p5.mysql.select:@"select c.id, c.parent, c.hyperlambda, p.command from commands c inner join phrases p on p.commandid = c.id 
where p.command = @command and c.parent is null and (c.username is null or c.username = @username)
order by `global`"
        @command:x:/../*/_arg?value
        @username:x:/@whoami/*/username?value

      /*
       * Adding command to buffer above.
       */
      add:x:/@.command
        src:x:/@p5.mysql.select/*/*

    /*
     * Make sure we show the user what we heard.
     */
    hyperlang.set-text:x:/../*/_arg?value

    /*
     * Making sure we set the position before we invoke the Hyperlambda, such that
     * any lambda object can explicitly reset the position, if they want to.
     *
     * Notice, we only update position if we found a command for phrase.
     */
    if:x:/@.command/*
      hyperlang.set-position:x:/@.command/*/id?value

    /*
     * Checking to see if we actually found a command.
     */
    if:x:/@.command/*

      /*
       * Success, we have a command in the current position, matching our 
       * specified [_arg].
       */
      hyper2lambda:x:/@.command/*/hyperlambda?value
      eval:x:/@hyper2lambda

    else

      /*
       * The specified [_arg] command doesn't exist, asking user if he wants to
       * create a new association for the given [_arg] command, or if he wants to
       * discard input, and rephrase his command.
       *
       * Waiting for user to say either "yes" or "no".
       *
       * Giving a visual clue to user, to inform him that he can say "teach"
       * to teach the computer a new word.
       */
      hyperlang.set-text:Say 'teach' to teach the computer a the word or phrase '{0}'
        :x:/../*/_arg?value
      eval-x:x:/+/*/*/*/*/hyperlang.create-phrase2hyper-association
      hyperlang.listen:[I don't understand]
        onfinish


          /*
           * Checking if user said "teach".
           */
          switch:x:/../*/text?value
            case:teach

              /*
               * Invoking Active Event responsible for creating a "phrase2hyper"
               * association, making sure we first retrieve what was spoken.
               */
              hyperlang.create-phrase2hyper-association:x:/../*/_arg?value

            default

              /*
               * Unless the user says "yes" or "no", we assume it's the actual
               * command he wanted to utter.
               */
              hyperlang.handle-input:x:/../*/text?value
